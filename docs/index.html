<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="format-detection" content="telephone=no" />
  <meta name="referrer" content="no-referrer" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; base-uri 'self'; object-src 'none'; frame-ancestors 'none'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src 'self'; form-action 'self';" />
  <title>🧳 여행용 환율 계산기</title>
  <style>

    
    :root {
      --bg1: #f3f8ff;
      --bg2: #eaf2ff;
      --card: rgba(255,255,255,0.92);
      --line: rgba(30, 80, 210, 0.14);
      --text: #0b1b3a;
      --muted: rgba(11,27,58,0.64);
      --accent: #2f7cff;
      --accent2: #00c2ff;
      --shadow: 0 18px 50px rgba(11, 27, 58, 0.12);
      --error-bg: #fff2f2;
      --error-line: #ffb3b3;
      --error-text: #8a1f1f;
    }
    * { box-sizing: border-box; }
    html { -webkit-text-size-adjust: 100%; }
    body {
      margin: 0;
      font-family: 'IBM Plex Sans KR', 'Apple SD Gothic Neo', 'Segoe UI', 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
      color: var(--text);
      background:
        radial-gradient(900px 420px at 18% 6%, rgba(47, 124, 255, 0.18), transparent 60%),
        radial-gradient(740px 360px at 86% 16%, rgba(0, 194, 255, 0.16), transparent 58%),
        radial-gradient(520px 320px at 70% 88%, rgba(47, 124, 255, 0.12), transparent 60%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      min-height: 100vh;
      padding: calc(22px + env(safe-area-inset-top)) calc(14px + env(safe-area-inset-right)) calc(18px + env(safe-area-inset-bottom)) calc(14px + env(safe-area-inset-left));
    }
    .wrap {
      position: relative;
      max-width: 820px;
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 22px;
      padding: 26px 22px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .app-version {
      position: fixed;
      right: calc(12px + env(safe-area-inset-right));
      bottom: calc(12px + env(safe-area-inset-bottom));
      z-index: 999;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: -0.01em;
      color: rgba(11,27,58,0.62);
      background: rgba(255,255,255,0.72);
      border: 1px solid rgba(47, 124, 255, 0.18);
      border-radius: 999px;
      padding: 6px 10px;
      user-select: none;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      box-shadow: 0 10px 18px rgba(11, 27, 58, 0.06);
      pointer-events: none;
    }

    .version-badge {
      position: absolute;
      top: 14px;
      right: 14px;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: -0.01em;
      color: rgba(11,27,58,0.70);
      background: rgba(255,255,255,0.72);
      border: 1px solid rgba(47, 124, 255, 0.18);
      border-radius: 999px;
      padding: 6px 10px;
      user-select: none;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    h1 {
      margin: 0;
      font-size: 30px;
      letter-spacing: -0.03em;
      padding-right: 90px; /* prevent overlap with version badge */
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 14px 0 10px;
    }
    .toolbar button, .toolbar select {
      border: 1px solid rgba(47, 124, 255, 0.22);
      border-radius: 12px;
      background: rgba(255,255,255,0.90);
      color: var(--text);
      font-weight: 900;
      height: 46px;
      min-height: 46px;
      padding: 0 14px;
      cursor: pointer;
      box-shadow: 0 10px 18px rgba(11, 27, 58, 0.06);
      line-height: 1;
    }
    .toolbar button:disabled { opacity: 0.5; cursor: not-allowed; }
    .toolbar select { padding-right: 36px; }
    .toolbar .count { font-size: 13px; color: var(--muted); font-weight: 900; }

    .grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }
    .field {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px;
      background: rgba(255,255,255,0.72);
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(140px, 220px);
      gap: 12px;
      align-items: end;
      box-shadow: 0 8px 22px rgba(11, 27, 58, 0.06);
    }
    .field > div { min-width: 0; }
    .field.hidden { display: none; }

    /* Labels are kept for accessibility but hidden from the visual UI. */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    .currency-row { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .currency-row select { min-width: 0; }
    .flag-big {
      width: 40px;
      height: 28px;
      object-fit: contain;
      display: block;
      user-select: none;
      flex: 0 0 auto;
    }

    .field input, .field select {
      width: 100%;
      border: 1px solid rgba(47, 124, 255, 0.24);
      border-radius: 14px;
      padding: 12px 14px;
      min-height: 50px;
      font-size: 17px;
      font-weight: 900;
      color: var(--text);
      background: rgba(255,255,255,0.95);
      font-variant-numeric: tabular-nums;
      font-family: 'IBM Plex Sans KR', 'Apple SD Gothic Neo', 'Segoe UI', 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif;
    }
    .field input { text-align: right; }

    .field input:focus, .field select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(47, 124, 255, 0.14);
    }

    .meta {
      margin-top: 16px;
      border: 1px dashed rgba(47, 124, 255, 0.25);
      border-radius: 16px;
      background: rgba(255,255,255,0.65);
      padding: 12px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.55;
      overflow-wrap: anywhere;
    }
    .error {
      margin-top: 14px;
      border: 1px solid var(--error-line);
      border-radius: 14px;
      background: var(--error-bg);
      color: var(--error-text);
      padding: 11px 12px;
      font-size: 14px;
    }

    body.kbd-open .wrap { padding: 14px 12px; border-radius: 16px; }
    body.kbd-open h1 { font-size: 20px; }
    body.kbd-open .toolbar button, body.kbd-open .toolbar select {
      height: 40px;
      min-height: 40px;
      padding: 0 10px;
      box-shadow: 0 6px 12px rgba(11, 27, 58, 0.05);
    }
    body.kbd-open .field { padding: 10px; border-radius: 14px; gap: 10px; }
    body.kbd-open .field input, body.kbd-open .field select { min-height: 40px; padding: 8px 10px; font-size: 15px; }
    body.kbd-open .flag-big { width: 32px; height: 22px; }
    body.kbd-open .meta { display: none; }

    @media (max-width: 760px) {
      .wrap { border-radius: 18px; padding: 18px 16px; }
      h1 { font-size: 26px; padding-right: 80px; }
      .field { grid-template-columns: 1fr; }
      .toolbar .count { width: 100%; }
    }

  </style>
</head>
<body>
  <main class="wrap">
    <h1>🧳 여행용 환율 계산기</h1>

    <section class="toolbar">
      <button type="button" id="add_field" aria-label="통화 추가" title="통화 추가">+ 추가</button>
      <button type="button" id="remove_field" aria-label="통화 제거" title="통화 제거">- 제거</button>
      <select id="rate_type">
        <option value="sale" selected>매매기준율</option>
        <option value="buy">현찰 사실 때</option>
        <option value="sell">현찰 파실 때</option>
        <option value="send">송금 보내실 때</option>
        <option value="receive">송금 받으실 때</option>
      </select>
      <span class="count" id="field_count_text"></span>
    </section>

    <section class="grid" id="grid"></section>

    <section class="meta" id="meta"></section>
    <div class="error" id="error" style="display:none;"></div>
  </main>

  <div class="app-version" id="app_version"></div>

  <script>
    const DEFAULT_CODES = ["USD", "KRW", "PHP", "EUR", "JPY"];
    const MIN_FIELDS = 1;
    const MAX_FIELDS = 5;
    let activeCount = 3;
    let lastEditedIndex = 0;
    let isSyncing = false;

    const addFieldBtn = document.getElementById("add_field");
    const removeFieldBtn = document.getElementById("remove_field");
    const rateTypeSelect = document.getElementById("rate_type");
    const fieldCountText = document.getElementById("field_count_text");
    const grid = document.getElementById("grid");
    const meta = document.getElementById("meta");
    const errorEl = document.getElementById("error");

    const UI_BUILD = "2026-02-08T10:50:32Z";



        const DEFAULT_UI_VERSION = '2239fa4';
    const UI_VERSION = (new URLSearchParams(window.location.search)).get('v') || DEFAULT_UI_VERSION;
const appVersionEl = document.getElementById("app_version");
    if (appVersionEl) {
      appVersionEl.textContent = `v${UI_VERSION}`;
      appVersionEl.title = `build ${UI_BUILD}`;
    }

    function updateKeyboardClass() {
      const vv = window.visualViewport;
      const baseH = window.innerHeight || 0;
      const vvH = vv ? vv.height : baseH;
      const ratio = baseH ? (vvH / baseH) : 1;

      const ae = document.activeElement;
      const tag = ae && ae.tagName ? ae.tagName.toLowerCase() : "";
      const isEditing = tag === "input" || tag === "select" || tag === "textarea";

      // The keyboard is considered "open" when the visual viewport shrinks.
      const openByViewport = vv ? (ratio < 0.78) : false;

      // Keep the version pill inside the visual viewport on mobile (iOS keyboard can cover fixed UI).
      if (appVersionEl && window.visualViewport) {
        const vv = window.visualViewport;
        const overlap = Math.max(0, (window.innerHeight || 0) - (vv.height + vv.offsetTop));
        appVersionEl.style.transform = overlap > 0 ? `translateY(${-overlap}px)` : "";
      }

      document.body.classList.toggle("kbd-open", Boolean(isEditing && openByViewport) || (!vv && isEditing));
    }

    function setupKeyboardCompactMode() {
      updateKeyboardClass();
      window.addEventListener("focusin", updateKeyboardClass);
      window.addEventListener("focusout", () => setTimeout(updateKeyboardClass, 80));

      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", updateKeyboardClass);
        window.visualViewport.addEventListener("scroll", updateKeyboardClass);
      } else {
        window.addEventListener("resize", updateKeyboardClass);
      }
    }

    setupKeyboardCompactMode();


    const TWEMOJI_SVG_BASE = "./assets/twemoji/svg/";
    const FLAG_SVG = {
      KRW: "1f1f0-1f1f7", // 🇰🇷
      USD: "1f1fa-1f1f8", // 🇺🇸
      CNY: "1f1e8-1f1f3", // 🇨🇳
      PHP: "1f1f5-1f1ed", // 🇵🇭
      TWD: "1f1f9-1f1fc", // 🇹🇼
      JPY: "1f1ef-1f1f5", // 🇯🇵
      VND: "1f1fb-1f1f3", // 🇻🇳
      THB: "1f1f9-1f1ed", // 🇹🇭
      EUR: "1f1ea-1f1fa", // 🇪🇺
      AUD: "1f1e6-1f1fa", // 🇦🇺
    };

    function flagUrl(code) {
      const file = FLAG_SVG[code];
      return file ? `${TWEMOJI_SVG_BASE}${file}.svg` : "";
    }


    function cleanEditableNumberText(value) {
      // Keep a permissive "in-progress" decimal format while typing:
      // - allow empty
      // - allow "1.", ".5"
      // - disallow negatives
      // - strip thousands separators
      const cleaned = String(value).replace(/,/g, "").trim();
      if (cleaned === "") return "";
      if (cleaned.includes("-")) return "";
      if (!/^\d*\.?\d*$/.test(cleaned)) return "";
      return cleaned;
    }

    function parseEditableNumber(value) {
      const cleaned = cleanEditableNumberText(value);
      if (cleaned === "") return { empty: true, cleaned: "", number: 0 };
      // "." alone should behave like "0." while editing.
      const normalized = cleaned === "." ? "0." : cleaned;
      const n = Number.parseFloat(normalized);
      return { empty: false, cleaned: normalized, number: Number.isFinite(n) && n >= 0 ? n : 0 };
    }

    function formatEditableNumberText(cleaned) {
      // cleaned: digits with optional '.' and fractional digits (no commas)
      if (cleaned === "") return "";
      const hasDot = cleaned.includes(".");
      let [intPart, fracPart] = cleaned.split(".");
      if (intPart === "") intPart = "0";
      intPart = intPart.replace(/^0+(?=\d)/, "");
      intPart = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      if (!hasDot) return intPart;
      if (fracPart === undefined) return `${intPart}.`;
      return `${intPart}.${fracPart}`;
    }

    function toInputValue(value) {
      // Default display is always 2 decimals (ex: 0.00).
      if (!Number.isFinite(value) || value < 0) return "0.00";
      const normalized = value.toFixed(2);
      const parts = normalized.split(".");
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      return parts.join(".");
    }

    function nonCommaIndex(text, caretPos) {
      let count = 0;
      for (let i = 0; i < Math.min(text.length, caretPos); i++) {
        if (text[i] !== ",") count += 1;
      }
      return count;
    }

    function caretPosFromNonCommaIndex(text, idx) {
      if (idx <= 0) return 0;
      let count = 0;
      for (let i = 0; i < text.length; i++) {
        if (text[i] !== ",") count += 1;
        if (count >= idx) return i + 1;
      }
      return text.length;
    }

    function setValuePreserveCaret(inputEl, formatted, oldText, oldCaret) {
      const idx = nonCommaIndex(oldText, oldCaret ?? oldText.length);
      inputEl.value = formatted;
      const pos = caretPosFromNonCommaIndex(inputEl.value, idx);
      try { inputEl.setSelectionRange(pos, pos); } catch { /* ignore */ }
    }

    function selectAllSoon(inputEl) {
      setTimeout(() => {
        try { inputEl.setSelectionRange(0, inputEl.value.length); } catch { /* ignore */ }
      }, 0);
    }

    function buildRow(i, currencies, flags) {
      const row = document.createElement("div");
      row.className = "field field-row";
      row.dataset.index = String(i);
      row.dataset.prevCode = DEFAULT_CODES[i] || "KRW";

      const left = document.createElement("div");
      const right = document.createElement("div");

      const wrap = document.createElement("div");
      wrap.className = "currency-row";
      const flag = document.createElement("img");
      flag.className = "flag-big";
      flag.id = `flag_${i + 1}`;
      flag.alt = "";
      flag.decoding = "async";
      flag.loading = "lazy";
      flag.src = flagUrl(row.dataset.prevCode);

      const sel = document.createElement("select");
      sel.id = `currency_${i + 1}`;
      sel.setAttribute("aria-label", "통화");
      currencies.forEach((c) => {
        const opt = document.createElement("option");
        opt.value = c.code;
        opt.textContent = c.label;
        if (c.code === (DEFAULT_CODES[i] || "KRW")) opt.selected = true;
        sel.appendChild(opt);
      });

      wrap.appendChild(flag);
      wrap.appendChild(sel);
      left.appendChild(wrap);

      const inp = document.createElement("input");
      inp.type = "text";
      inp.inputMode = "decimal";
      inp.id = `amount_${i + 1}`;
      inp.setAttribute("aria-label", "금액");
      inp.value = "0.00";
      inp.placeholder = "0.00";

      right.appendChild(inp);

      row.appendChild(left);
      row.appendChild(right);
      return { row, sel, inp, flag };
    }

    function refreshRows(fields) {
      fields.forEach((f, idx) => f.row.classList.toggle("hidden", idx >= activeCount));
      fieldCountText.textContent = `표시 중: ${activeCount} / ${MAX_FIELDS}`;
      addFieldBtn.disabled = activeCount >= MAX_FIELDS;
      removeFieldBtn.disabled = activeCount <= MIN_FIELDS;
    }

    function currentRates(ratesByType) {
      const t = rateTypeSelect.value;
      return ratesByType[t] || ratesByType["sale"];
    }

    function canConvertSelected(ratesByType, fields) {
      const r = currentRates(ratesByType);
      const activeFields = fields.slice(0, activeCount);
      return activeFields.every((f) => Number.isFinite(r[f.sel.value]) && r[f.sel.value] > 0);
    }

    function convertAmount(ratesByType, amount, fromCode, toCode) {
      if (fromCode === toCode) return amount;
      const r = currentRates(ratesByType);
      const inKrw = amount * r[fromCode];
      return inKrw / r[toCode];
    }

    function applyEnabledState(ratesByType, fields) {
      const ok = canConvertSelected(ratesByType, fields);
      const activeFields = fields.slice(0, activeCount);
      activeFields.forEach((f) => { f.inp.disabled = !ok; f.sel.disabled = false; });
      fields.slice(activeCount).forEach((f) => { f.inp.disabled = true; f.sel.disabled = true; });
      if (!ok) fieldCountText.textContent = `표시 중: ${activeCount} / ${MAX_FIELDS} (환율 데이터 부족)`;
      return ok;
    }


    function formatRateValue(value) {
      // For rate display, 4 decimals is useful for smaller currencies (ex: JPY/VND).
      if (!Number.isFinite(value) || value <= 0) return "-";
      const s = value.toFixed(4);
      const parts = s.split(".");
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      return parts.join(".");
    }

    function renderMeta(data) {
      const typeLabel = rateTypeSelect.options[rateTypeSelect.selectedIndex]?.textContent ?? "";

      // Keep meta text-only.
      meta.replaceChildren();

      const line1 = document.createElement("div");
      line1.appendChild(document.createTextNode("환율 기준: "));
      const strong = document.createElement("strong");
      strong.textContent = typeLabel;
      line1.appendChild(strong);

      const line2 = document.createElement("div");
      line2.textContent = `업데이트: ${data.fetched_at || "-"}`;

      const line3 = document.createElement("div");
      line3.textContent = data.source ? `출처: 네이버 금융 (${data.source})` : "출처: 네이버 금융";

      meta.appendChild(line1);
      meta.appendChild(line2);
      meta.appendChild(line3);
    }


    function updateFrom(ratesByType, fields, index, preserveSourceCaret = false, sourceOldText = "", sourceOldCaret = 0) {
      if (isSyncing) return;
      isSyncing = true;

      const activeFields = fields.slice(0, activeCount);
      const source = activeFields[index];
      if (!source) { isSyncing = false; return; }
      const sourceCode = source.sel.value;
      const parsed = parseEditableNumber(source.inp.value);
      if (parsed.empty) {
        // If user cleared the field, keep it empty and clear dependent fields.
        activeFields.forEach((f, i) => { if (i !== index) f.inp.value = ""; });
        isSyncing = false;
        return;
      }
      const sourceAmount = parsed.number;
      // Keep "in-progress" trailing dot while typing, otherwise normalize to the same
      // computed format as other fields (so all rows behave consistently).
      const sourceFormatted = parsed.cleaned.endsWith(".")
        ? formatEditableNumberText(parsed.cleaned)
        : toInputValue(sourceAmount);
      if (preserveSourceCaret) setValuePreserveCaret(source.inp, sourceFormatted, sourceOldText, sourceOldCaret);
      else source.inp.value = sourceFormatted;

      activeFields.forEach((f, i) => {
        if (i === index) return;
        const converted = convertAmount(ratesByType, sourceAmount, sourceCode, f.sel.value);
        f.inp.value = toInputValue(converted);
      });

      isSyncing = false;
    }

    async function load() {
      const res = await fetch(`./data/rates.json?t=${Date.now()}`);
      if (!res.ok) throw new Error("rates.json not found");
      return await res.json();
    }

    load().then((data) => {
      const ratesByType = data.rates_by_type;
      const currencies = data.currencies;
      const flags = {};
      currencies.forEach((c) => { flags[c.code] = c.flag; });

      const fields = [];
      for (let i = 0; i < MAX_FIELDS; i++) {
        const f = buildRow(i, currencies, flags);
        fields.push(f);
        grid.appendChild(f.row);
      }

      function setPrevCode(i, code) { fields[i].row.dataset.prevCode = code; }
      function getPrevCode(i) { return fields[i].row.dataset.prevCode || fields[i].sel.value; }
      fields.forEach((f, i) => setPrevCode(i, f.sel.value));

      fields.forEach((f, idx) => {
        f.inp.addEventListener("focus", () => { lastEditedIndex = idx; selectAllSoon(f.inp); });
        f.inp.addEventListener("click", () => { lastEditedIndex = idx; selectAllSoon(f.inp); });
        f.inp.addEventListener("input", () => {
          const oldText = f.inp.value;
          const oldCaret = f.inp.selectionStart ?? oldText.length;
          lastEditedIndex = idx;
          updateFrom(ratesByType, fields, idx, true, oldText, oldCaret);
        });
        f.inp.addEventListener("blur", () => {
          // If the user leaves the field empty, snap back to the default "0".
          const parsed = parseEditableNumber(f.inp.value);
          lastEditedIndex = idx;
          if (parsed.empty) {
            f.inp.value = "0.00";
            updateFrom(ratesByType, fields, idx);
            return;
          }
          // On blur, normalize to computed format (no trailing dot, trim zeros).
          f.inp.value = toInputValue(parsed.number);
          updateFrom(ratesByType, fields, idx);
        });
        f.sel.addEventListener("change", () => {
          const oldCode = getPrevCode(idx);
          const newCode = f.sel.value;
          f.flag.src = flagUrl(newCode);
          const ok = applyEnabledState(ratesByType, fields);
          if (!ok) return;

        if (idx === lastEditedIndex) {
          const r = currentRates(ratesByType);
          const amountOld = parseEditableNumber(f.inp.value).number;
          const krwValue = amountOld * r[oldCode];
          const amountNew = krwValue / r[newCode];
          f.inp.value = toInputValue(amountNew);
          setPrevCode(idx, newCode);
          updateFrom(ratesByType, fields, idx);
          return;
        }

          setPrevCode(idx, newCode);
          const sourceIndex = Math.min(lastEditedIndex, activeCount - 1);
          updateFrom(ratesByType, fields, sourceIndex);
        });
      });

      rateTypeSelect.addEventListener("change", () => {
        applyEnabledState(ratesByType, fields);
        renderMeta(data);
        const sourceIndex = Math.min(lastEditedIndex, activeCount - 1);
        updateFrom(ratesByType, fields, sourceIndex);
      });
      addFieldBtn.addEventListener("click", () => {
        if (activeCount >= MAX_FIELDS) return;
        activeCount += 1;
        refreshRows(fields);
        applyEnabledState(ratesByType, fields);
        const sourceIndex = Math.min(lastEditedIndex, activeCount - 1);
        updateFrom(ratesByType, fields, sourceIndex);
      });
      removeFieldBtn.addEventListener("click", () => {
        if (activeCount <= MIN_FIELDS) return;
        activeCount -= 1;
        refreshRows(fields);
        applyEnabledState(ratesByType, fields);
        const sourceIndex = Math.min(lastEditedIndex, activeCount - 1);
        updateFrom(ratesByType, fields, sourceIndex);
      });

      refreshRows(fields);
      applyEnabledState(ratesByType, fields);
      updateFrom(ratesByType, fields, 0);

      renderMeta(data);
    }).catch((e) => {
      errorEl.style.display = "block";
      errorEl.textContent = `환율 데이터를 불러오지 못했습니다: ${e.message}`;
    });
  </script>
</body>
</html>












